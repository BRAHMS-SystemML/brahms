
%__________________________________________________________________________
%
% This file is part of BRAHMS
% Copyright (C) 2007 Ben Mitchinson
% URL: http://brahms.sourceforge.net
%
% This program is free software; you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation; either version 2 of the License, or (at your
% option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%
% You should have received a copy of the GNU General Public License along
% with this program; if not, write to the Free Software Foundation, Inc.,
% 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
%__________________________________________________________________________
%
% $Id:: tutorial_1.m 1752 2009-04-02 01:03:15Z benjmitch                 $
% $Rev:: 1752                                                            $
% $Author:: benjmitch                                                    $
% $Date:: 2009-04-02 02:03:15 +0100 (Thu, 02 Apr 2009)                   $
%__________________________________________________________________________
%


% Tutorial 1 : A single process
%
% By the end of this tutorial you should understand the
% following concepts:
%
%   * the existence of the BRAHMS standard library
%   * how to set up the parameters of a BRAHMS process
%   * how the std/source/numeric library process works
%   * setting up a basic BRAHMS execution
%   * running a BRAHMS execution from Matlab
%   * reading the output of a BRAHMS execution
%
% Extra credit tasks are listed at the end of this code

% We first create an empty system specification (no
% processes), called "sys", an "sml_system" (SystemML
% system). When we are finished being creative, this will be
% a complete description of the system to be executed.
sys = sml_system;

% We then create a process of type source/numeric, which is
% a source of explicitly-specified numeric data (see
% http://brahms.sourceforge.net/docs/std_source_numeric.html for
% documentation). At each sample, we want this process to
% output an array of dimension 1x2, and we want to specify
% the content of that array for 3 output samples. Hence, the
% initialisation data we pass to the process has size 1x2x3,
% where the last dimension is the sample number of the
% output. First, we construct the initialisation parameters
% (more generally, the initial state).
state = [];
state.data = 42*ones(1,2,3);  % 1x2 matrix, 3 samples
state.repeat = false;         % doesn't repeat the block of data

% We add this process to the system calling it "src". src,
% thus, will be the name of this process within the system
% we are building. Note that the name of a process must be
% unique within a system. We set the sample rate of the
% process to 3Hz - for now, we can pretend that setting the
% sample rate of a process is equivalent to setting the
% sample rates of all outputs of that process. "addprocess"
% takes four arguments here: (name, class, sample rate,
% state) 'state' is the set of initial parameters for the
% process being added.
sys = sys.addprocess('src', 'std/2009/source/numeric', 3, state);

% Next, we create a default execution, "exe", a
% "brahms_execution", which is an object containing the
% specification of an execution. We then modify two fields
% of that object: "executionStop" specifying the time (in
% seconds) at which the execution should cease, and "all"
% specifying that all outputs of the system should be
% logged. Logging takes time, so for high-performance you
% will want to avoid logging all outputs; however, it's
% standard practice during development.
exe = brahms_execution;
exe.executionStop = 1;    % stop the exe after one second
exe.all = true;           % log all outputs of the system

% Finally, we run the execution, by passing the system and
% execution objects to the BRAHMS launcher, and requesting
% one output, which will be a structure containing all
% logged outputs.
out = brahms(sys, exe);

% We can now examine the output structure that was returned
% by BRAHMS
disp([repmat('_',1,60) 10])    % this just writes a line across the screen
disp('*** Output structure')
disp('out')
disp(out)

% When we log the outputs of a process called "src", as we
% have done, a field is created in the output structure,
% also called "src", which contains all the logs of outputs
% of that process.
disp([repmat('_',1,60) 10])
disp('*** All outputs from process "src"')
disp('out.src')
disp(out.src)

% An output generated by a process "src" is returned in the
% output structure by the BRAHMS launcher as a sub-field of
% "out.src". The sub-field is called for the output. The
% std/source/numeric class generates one output, and it is
% always named "out", so in this case we find our output at
% "out.src.out".
disp([repmat('_',1,60) 10])
disp('*** Numeric output')
disp('out.src.out')
disp(out.src.out)

% For numeric array data objects, the format of the output
% log is a D1xD2x...xDnxM matrix, where the dimension of
% the data object is D1xD2x...xDn, and the object was logged
% for M samples. In this case, we logged 3 samples (1 second
% at 3Hz), and the data object was of dimension 1x2, so the
% output is of size...
disp([repmat('_',1,60) 10])
disp('*** Size of numeric output')
disp('size(out.src.out)')
disp(size(out.src.out))

% The output at the first sample, thus, can be extracted as
% follows:
disp([repmat('_',1,60) 10])
disp('*** Output at first sample')
disp('out.src.out(:,:,1)')
disp(out.src.out(:,:,1))

% FOR A COMPLETE UNDERSTANDING:
%
%   * Try changing the size of the numeric source, and the
%   number of samples that are executed. Try using different
%   data values, so that you can see what goes where.
%
%   * Set the sample rate of the numeric source process to
%   be greater than the number of samples supplied, and keep
%   the execution stop time at one second; an error will
%   occur. Set "state.repeat = true" and check the output -
%   this fixes the problem by repeating the block of numeric
%   data until the end of the execution.
%   
%   * Does it make any difference whether you execute 1
%   second at 100Hz or 100 seconds at 1Hz? Why or why not?
